===========================================================
Задача 1
1. Что выведет на экран и сколько времени будет работать?
2. Нужно ускорить, чтобы работало быстрее. Сколько будет работать теперь?
3. Если бы в networkRequest выполнялся реальный сетевой вызов, то какие с какими проблемами мы могли бы столкнуться в данном коде?
4. Если url немного, а запросов к ним много, то как можно оптимизировать?
===========================================================

package main

import (
    "fmt"
    "time"
)

const numRequests = 10000

var count int

var m sync.Mutex

func networkRequest() {
    time.Sleep(time.Millisecond) // Эмуляция сетевого запроса.
    m.Lock()
    count++
    m.Unlock()
}

func main() {
    var wg sync.WaitGroup

    wg.Add(numRequests)
    for i := 0; i < numRequests; i++ {
        go func() {
            defer wg.Done()
            networkRequest()
        }()
    }

    wg.Wait()
    fmt.Println(count)
}


===========================================================
Задача 2

===========================================================

// Есть функция unpredictableFunc, работающая неопределенно долго и возвращающая число.
// Её тело нельзя изменять (представим, что внутри сетевой запрос).

// Нужно написать обертку predictableFunc, 
// которая будет работать с заданным фиксированным таймаутом (например, 1 секунду).

package main

import (
    "fmt"
    "math/rand"
    "time"
)

func init() {
    rand.Seed(time.Now().UnixNano())
}

// Есть функция, работающая неопределенно долго и возвращающая число.
// Её тело нельзя изменять (представим, что внутри сетевой запрос).
func unpredictableFunc() int64 {
    rnd := rand.Int63n(5000)
    time.Sleep(time.Duration(rnd) * time.Millisecond)

    return rnd
}

// Нужно изменить функцию обертку, которая будет работать с заданным таймаутом (например, 1 секунду).
// Если "длинная" функция отработала за это время - отлично, возвращаем результат.
// Если нет - возвращаем ошибку. Результат работы в этом случае нам не важен.
//
// Дополнительно нужно измерить, сколько выполнялась эта функция (просто вывести в лог).
// Сигнатуру функцию обёртки менять можно.
func predictableFunc() int64 {
}

func main() {
    fmt.Println("started")

    fmt.Println(predictableFunc())
}

===========================================================
Задача 3
1. Релизовать ручку так, чтобы она выполнялась быстрее чем за одну секунду
2. Теперь допустим, что запрашивается температура в каком-то location_id. Опиши, как это реализовать. 
===========================================================

// Есть функция getWeather, которая через нейронную сеть вычисляет температуру за ~1 секунду
// Есть highload ручка /weather/highload с нагрузкой 3k RPS
// Необходимо реализовать код этой ручки

func getWeather() int {
    time.Sleep(1 * time.Second)
    return rand.Intn(70) - 30
}

func main() {
    http.HandleFunc("/weather/highload", func(resp http.ResponseWriter, req *http.Request) {


    })
}