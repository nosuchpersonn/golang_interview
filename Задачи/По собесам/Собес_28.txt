===========================================================
Задача 1
===========================================================

// Написать код функции, которая делает merge N каналов. Весь входной поток перенаправляется в один канал.

func merge(cs ...<-chan int) <-chan int {
}

===========================================================
Задача 2
1. Реализовать кеш. Для простоты считаем, что у нас бесконечная память и нам не нужно задумываться об удалении ключей из него.
	1. Почему использовал RWMutex, а не Mutex?
2. Теперь представим что память не бесконечная. С какими проблемами столкнемся и как их решить?
	1. Какие есть алгоритмы выселения?
3. Реализуй LRU
===========================================================

// In-memory cache
// Нужно написать простую библиотеку in-memory cache.
// Реализация должна удовлетворять интерфейсу:

type Cache interface {
    Set(k, v string)
    Get(k string) (v string, ok bool)
}

===========================================================
Задача 3
1. Что выведется? Исправь проблему
===========================================================

# Вариант1
----------
x := make(map[int]int, 1)
go func() { x[1] = 2 }()
go func() { x[1] = 7 }()
go func() { x[1] = 10 }()
time.Sleep(100 * time.Millisecond)
fmt.Println("x[1] =", x[1])


===========================================================
Задача 4
1. Иногда приходят нули. В чем проблема? Исправь ее
2. Если функция bank_network_call выполняется 5 секунд, то за сколько выполнится balance()? Как исправить проблему?
3. Представим, что bank_network_call возвращает ошибку дополнительно. Если хотя бы один вызов завершился с ошибкой, то balance должен вернуть ошибку.
===========================================================

func balance() int {
    x := make(map[int]int, 1)
    var m sync.Mutex
 
    // call bank
    for i := 0; i < 5; i++ {
        i := i
        go func() {
	    m.Lock()
            b := bank_network_call(i)
        
            x[i] = b
            m.Unlock()
        }()
    }

    // Как-то считается сумма значений в мапе и возвращается
    return sumOfMap
}

===========================================================
Задача 5
1. Составить схему БД
2. Написать запрос - выбрать названия всех книг которые на руках
3. Написать запрос - выбрать названия всех книг в библиотеке у которых больше 3 авторов
4. Написать запрос - выбрать имена топ 3 читаемых авторов на данный момент
5. 
6. В каких случаях бы ты 
===========================================================

Библиотека
Нужно описать модель библиотеки. Есть 3 сущности: "Автор", "Книга", "Читатель"
Физически книга только одна и может быть только у одного читателя. Нужно составить таблицы для библиотеки так чтобы это учесть.


===========================================================
Задача 6
===========================================================

Вопрос о медленном сервисе
На примере создания заказа. Есть запрос на сервис и есть ответ, между этими двумя действиями мы сладываем в аналитику товары которые заказали 
(например для подсчета популярности товаров). Сервис аналитики переодически работает медленно или вовсе таймаутит, и мы не успеваем ответить, теряем заказы.

// Данные которые приходят
SetOtrder
{
    id 
    status //ожидает оплаты, оплата, оплачен   
}

// Последовательность операций
1 запрос
2 пишем в бд
3 отправляем запрос в аналитику
4 возвращаем ответ

﻿Что делать, что бы перестать терять заказы, и деньги соответсвенно?
Необходимо подробно описать последовательность действий, и какие данные сохраняются/передаются. Если появляется дополнительная работа с БД, то написать соответствующие SQL запросы. Нужно учитывать, что это хайлоад. 